#install.packages('tidyverse')
library(tidyverse)
#install.packages('microseq')
library(microseq)
#install.packages('gtools')
library(gtools)

library(muscle)

#This data is from a Thermo Ion S5 sequencer. 
#Metabarcoding data from a malaise trap ontario provincial parks dataset
data = readFastq('/home/cnuge/Documents/barcode_data/mBRAVE_raw_read_data/GMP-03299)CCDB-S5-0084)CBGMB-00030.fastq')

#on server
#data = readFastq('/home/cnugent/barcode_data/mBRAVE_raw_read_data/GMP-04500)CCDB-S5-0084)CBGMB-00030.fastq')

head(data)
names(data)

#Columns are header, sequence and quality.... can the quality column be leveraged?

#In FASTQ files, quality scores are encoded into a compact form, 
#which uses only 1 byte per quality value. In this encoding, 
#the quality score is represented as the character with an ASCII code equal to its value + 33.
#A Phred quality score is a measure of the quality of the identification of the nucleobases generated by automated DNA sequencing.
#Phred quality scores Q are defined as a property which is logarithmically related to the base-calling error probabilities P
#For example, if Phred assigns a quality score of 30 to a base, the chances that this base is called incorrectly are 1 in 1000.

#here is code for getting the quality information into a numeric vector, matches the positions in the 
#sequence strings, these could be passed in to a stastical model along with the 

phred_string = data$Quality[1]
phred_string

phred2numeric = function(phred_string){
	outvec = asc(unlist(strsplit(phred_string, "")))
	return(outvec - 33)
}

test = head(data)
test$qual_vec = lapply(test$Quality , function(x){phred2numeric(x)})
head(test)

#is using the phred scores as an input feature, would pass them in as another tensor to the input of the model

#if using artifical training data, would need to find the distribution of phred scores for inserted data, and the 
#distribution of phred scores of data next to deletions and then randomly assign phred scores based on these ditributions.
#^maybe best to go with real world data if using a phred layer on the input


#####
#try to dereplicate these reads




####
# try to align the reads to one another

#a hypothetical 'true' sanger sequence
s1 = 'actttatactttctctttcggaagatgggcaggtatagttggaacctctttgaagcttacttattcgtgccgaactgggaaatcctgggacattaatcggagatgaccaaatttacaatgttattgtaactgcacatgcatttgtaataattttctttatagtaatacctattatgattggagggtttggaaattggctggtacccctgatacttggcgcccctgacatagcattcccccgaataaataatataagattctgattattacccccttccctaactctccttttaataagaagccttgtagaaaggggggccggtaccggatggacagtatacccgcccctatctgccaatattgcccatagaggggcttctgtagacttagccatttttagcctccacttagccggtatctcatcaattttgggagctgtgaattttattactaccgttattaacatacgttctacaggaatgacctttgaccgaatacccctatttgtttgatcagtagctttaactgcccttcttcttcttctgtctcttcccgtattagcaggcgcaatcactatacttttaacagaccgaaatattaatacgtcattctttgaccctgcgggaggaggagaccccattctataccaacatttattt'
#two hypothetical HTS datasets, with errors
s2 = 'actttatacttttctctttcggaagatggcaggtatagttggaacctctttgaagctttacttattcgtgcccgaactgggaatcctgggacattaatcggagatgaccaaaattacaatgttattgtaactgcacatgcatttgtaataattttctttatagtaatacctattatgattggagggtttggaaattggctggtacccctgatacttggcgcccctgacatagcattcccccgaataaataatataagattctgattattacccccttccctaactctccttttaataagaagccttgtagaaaggggggccggtaccggatggacagtatacccgcccctatctgccaatattgcccatagaggggcttctgtagacttagccatttttagcctccacttagccggtatctcatcaattttgggagctgtgaattttattactaccgttattaacatacgttctacaggaatgacctttgaccgaatacccctatttgtttgatcagtagctttaactgcccttcttcttcttctgtctcttcccgtattagcaggcgcaatcactatacttttaacagaccgaaatattaatacgtcattctttgaccctgcgggaggaggagaccccattctataccaacatttattt'
s3 = 'acttttatacatttctcttcggaagatggggcaggtatagttggaacctctttgaagcttacttattcgtgccgaaactgggaaatcctgggacatttaatcggagatgaccaaatttacaatgttattgtaactgcacatgcatttgtaataattttctttatagtaatacctattatgattggagggtttggaaattggctggtacccctgatacttggcgcccctgacatagcattcccccgaataaataatataagattctgattattacccccttccctaactctccttttaataagaagccttgtagaaaggggggccggtaccggatggacagtatacccgcccctatctgccaatattgcccatagaggggcttctgtagacttagccatttttagcctccacttagccggtatctcatcaattttgggagctgtgaattttattactaccgttattaacatacgttctacaggaatgacctttgaccgaatacccctatttgtttgatcagtagctttaactgcccttcttcttcttctgtctcttcccgtattagcaggcgcaatcactatacttttaacagaccgaaatattaatacgtcattctttgaccctgcgggaggaggagaccccattctataccaacatttattt'

?DNAStringSet
DNAStringSet()

## When the input vector contains a lot of duplicates, turning it into
## a factor first before passing it to the constructor will produce an
## XStringSet object that is more compact in memory:

#take a sanger-hts pair, align them to one another and then characterize the errors
pairwise_align = function(s1, s2){

	align = DNAStringSet(muscle::muscle(DNAStringSet(c(s1, s2)), maxiters = 2))
	a1 = unlist(strsplit(as.character(align[[1]]),"")) 
	a2 = unlist(strsplit(as.character(align[[2]]),""))

	return(list(a1=a1, a2=a2)
}

#TODO - trim the pairwise alignment to the length of the IONTORRENT seequence
#will likely have most the sequences <658 bp (quantify once real data) so we 
#need to make sure the ------- at the end of the alignment aren't biasing the results
#slice a1 and a1 to remove trailing dashes on the Iontorrent read, and the corresponding
#bases on the true sanger sequence.


#this function will take in an aligned pair of sanger-hts sequences
#and count the number of insertions, deletions and mutations for each bp
characterize_errors = function(a1, a2){

	insertions = list(a= 0, t= 0, g= 0, c= 0)
	deletions  = list(a= 0, t= 0, g= 0, c= 0)
	
	#row = the sanger base
	#column = what it mutated to in the HTS data
	mutations = data.frame(a=rep(0,4),
								t=rep(0,4),
								g=rep(0,4),
								c=rep(0,4),
								row.names = c('a', 't','g','c'))

	insertion_pos = c()
	deletion_pos = c()
	mutation_pos = c()

	for(i in 1:length(a1)){
		if(a1[i] != a2[i]){

			#inserted base in HTS 
			if(a1[i] == '-'){
				insertions[a2[i]] = insertions[a2[i]] + 1 
				insertion_pos = c(insertion_pos, i)
			}
			#deleted base in HTS
			if(a2[i] == '-'){
				deletions[a1[i]] = deletions[a1[i]] + 1 
				deletion_pos = c(deletion_pos, i)

			}
			#mutation
			else{
				mutations[a1[i], a2[i]] = mutations[a1[i], a2[i]] + 1
				mutation_pos = c(mutation_pos , i)				
			}
		}
	}

	bp_dat = list(insertions = insertions, deletions = deletions, mutations = mutations)
	error_positions = list(insertion_pos = insertion_pos , deletion_pos = deletion_pos , mutation_pos = mutation_pos )
	return(list(bp_dat = bp_dat, error_positions = error_positions))
}

#this function takes an aligned pair of sanger-hts sequences and determines how many of the
#indels are associated with homopolymers in the true sequence
homopolymer_indels = function(a1,a2){

	hpols = data.frame(non_hp=rep(0,4),
						two_hp=rep(0,4),
						three_hp=rep(0,4),
						quad_plus_hp=rep(0,4),
						row.names = c('a', 't','g','c'))

	#before writing this look at some examples, are the hps always before or after the indels?
	#or do we need to check the bp to both sides of the indel

}




